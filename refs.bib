@article{10.14778/3282495.3282500,
  author     = {Suboti\'{c}, Pavle and Jordan, Herbert and Chang, Lijun and Fekete, Alan and Scholz, Bernhard},
  title      = {Automatic index selection for large-scale datalog computation},
  year       = {2018},
  issue_date = {October 2018},
  publisher  = {VLDB Endowment},
  volume     = {12},
  number     = {2},
  issn       = {2150-8097},
  url        = {https://doi.org/10.14778/3282495.3282500},
  doi        = {10.14778/3282495.3282500},
  abstract   = {Datalog has been applied to several use cases that require very high performance on large rulesets and factsets. It is common to create indexes for relations to improve search performance. However, the existing indexing schemes either require manual index selection or result in insufficient performance on very large tasks. In this paper, we propose an automatic scheme to select indexes. We automatically create the minimum number of indexes to speed up all the searches in a given Datalog program. We have integrated our indexing scheme into an open-source Datalog engine SOUFFL\'{E}. We obtain performance on a par with what users have accepted from hand-optimized Datalog programs running on state-of-the-art Datalog engines, while we do not require the effort of manual index selection. Extensive experiments on large real Datalog programs demonstrate that our indexing scheme results in considerable speedups (up to 2x) and significantly less memory usage (up to 6x) compared with other automated index selections.},
  journal    = {Proc. VLDB Endow.},
  month      = {oct},
  pages      = {141–153},
  numpages   = {13}
}

@article{DBS-073,
  url     = {http://dx.doi.org/10.1561/1900000073},
  year    = {2022},
  volume  = {12},
  journal = {Foundations and Trends® in Databases},
  title   = {Modern Datalog Engines},
  doi     = {10.1561/1900000073},
  issn    = {1931-7883},
  number  = {1},
  pages   = {1-68},
  author  = {Bas Ketsman and Paraschos Koutris}
}

@book{10.5555/551350,
  author    = {Abiteboul, Serge and Hull, Richard and Vianu, Victor},
  title     = {Foundations of Databases: The Logical Level},
  year      = {1995},
  isbn      = {0201537710},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address   = {USA},
  edition   = {1st},
  abstract  = {From the Publisher:Over the past two decades, the theory concerning the logical level of database management systems has matured and become an elegant and robust piece of science. Foundations of Databases presents indepth coverage of this theory and surveys several emerging topics. Written by three leading researchers, this advanced text presents a unifying and contemporary perspective on the field. A major effort in writing the book has been to highlight the intuitions behind the theoretical development.}
}

@article{PGL-014,
  url     = {http://dx.doi.org/10.1561/2500000014},
  year    = {2015},
  volume  = {2},
  journal = {Foundations and Trends® in Programming Languages},
  title   = {Pointer Analysis},
  doi     = {10.1561/2500000014},
  issn    = {2325-1107},
  number  = {1},
  pages   = {1-69},
  author  = {Yannis Smaragdakis and George Balatsouras}
}

@article{10.1145/319628.319663,
  author     = {Lehman, Philip L. and Yao, s. Bing},
  title      = {Efficient locking for concurrent operations on B-trees},
  year       = {1981},
  issue_date = {Dec. 1981},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {6},
  number     = {4},
  issn       = {0362-5915},
  url        = {https://doi.org/10.1145/319628.319663},
  doi        = {10.1145/319628.319663},
  abstract   = {The B-tree and its variants have been found to be highly useful (both theoretically and in practice) for storing large amounts of information, especially on secondary storage devices. We examine the problem of overcoming the inherent difficulty of concurrent operations on such structures, using a practical storage model. A single additional “link” pointer in each node allows a process to easily recover from tree modifications performed by other concurrent processes. Our solution compares favorably with earlier solutions in that the locking scheme is simpler (no read-locks are used) and only a (small) constant number of nodes are locked by any update process at any given time. An informal correctness proof for our system is given.},
  journal    = {ACM Trans. Database Syst.},
  month      = {dec},
  pages      = {650–670},
  numpages   = {21},
  keywords   = {multiway search trees, locking protocols, index organizations, database, data structures, correctness, consistencey, concurrency controls, concurrenct algorithms, B-tree}
}

@article{AFRATI1995177,
  title    = {On Datalog vs Polynomial Time},
  journal  = {Journal of Computer and System Sciences},
  volume   = {51},
  number   = {2},
  pages    = {177-196},
  year     = {1995},
  issn     = {0022-0000},
  doi      = {https://doi.org/10.1006/jcss.1995.1060},
  url      = {https://www.sciencedirect.com/science/article/pii/S0022000085710604},
  author   = {F. Afrati and S.S. Cosmadakis and M. Yannakakis},
  abstract = {We show that certain monotonic polynomial time queries are not expressible in variants of Datalog. The proof techniques include lower bounds for monotone circuit size and a "Pumping Lemma" for Datalog queries.}
}

@article{ROSS199779,
  title    = {Monotonic Aggregation in Deductive Databases},
  journal  = {Journal of Computer and System Sciences},
  volume   = {54},
  number   = {1},
  pages    = {79-97},
  year     = {1997},
  issn     = {0022-0000},
  doi      = {https://doi.org/10.1006/jcss.1997.1453},
  url      = {https://www.sciencedirect.com/science/article/pii/S0022000097914537},
  author   = {Kenneth A Ross and Yehoshua Sagiv},
  abstract = {We propose a semantics for aggregates in deductive databases based on a notion of minimality. Unlike some previous approaches, we form a minimal model of a program component including aggregate operators, rather than insisting that the aggregate apply to atoms that have been fully determined or that aggregate functions are rewritten in terms of negation. In order to guarantee the existence of such a minimal model we need to insist that the domains over which we are aggregating are complete lattices and that the program is in a sense mono- tonic. Our approach generalizes previous approaches based on the well-founded semantics and various forms of stratification. We are also able to handle a large variety of monotonic (or pseudo-monotonic) aggregate functions.}
}
@inproceedings{greco_datalog_2016,
  address   = {Cham},
  series    = {Synthesis {Lectures} on {Data} {Management}},
  title     = {Datalog and {Logic} {Databases}},
  copyright = {https://www.springer.com/tdm},
  isbn      = {978-3-031-00726-2 978-3-031-01854-1},
  url       = {https://link.springer.com/10.1007/978-3-031-01854-1},
  doi       = {10.1007/978-3-031-01854-1},
  abstract  = {Abstract The use of logic in databases started in the late 1960s. In the early 1970s Codd formalized databases in terms of the relational calculus and the relational algebra. A major influence on the use of logic in databases was the development of the field of logic programming. Logic provides a convenient formalism for studying classical database problems and has the important property of being declarative, that is, it allows one to express what she wants rather than how to get it. For a long time, relational calculus and algebra were considered the relational database languages. However, there are simple operations, such as computing the transitive closure of a graph, which cannot be expressed with these languages. Datalog is a declarative query language for relational databases based on the logic programming paradigm. One of the peculiarities that distinguishes Datalog from query languages like relational algebra and calculus is recursion, which gives Datalog the capability to express queries like com...},
  language  = {en},
  urldate   = {2024-06-09},
  publisher = {Springer International Publishing},
  author    = {Greco, Sergio and Molinaro, Cristian},
  year      = {2016},
  doi       = {10.1007/978-3-031-01854-1},
  file      = {Datalog and Logic Databases:C\:\\Users\\zijun\\Zotero\\storage\\7XTZX9WR\\Datalog and Logic Databases.pdf:application/pdf}
}

@misc{postgres_readme,
  author = {PostgreSQL},
  title  = {README for nbtree in PostgreSQL source code},
  year   = {2024},
  note   = {Available at: \url{https://github.com/postgres/postgres/blob/00ac25a/src/backend/access/nbtree/README#L112-L137}, commit hash: 00ac25a}
}
